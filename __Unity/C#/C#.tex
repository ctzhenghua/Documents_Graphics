\documentclass[UTF8,a4paper,12pt]{ctexbook} 

\usepackage{graphicx}%学习插入图
\usepackage{verbatim}%学习注释多行
\usepackage{booktabs}%表格
\usepackage{geometry}%图片
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}%代码
\usepackage{xcolor}  %颜色
\usepackage{enumitem}%列表格式
\setenumerate[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\setitemize[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\setdescription{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\usepackage{tcolorbox}
\usepackage{algorithm}  %format of the algorithm
\usepackage{algorithmic}%format of the algorithm
\usepackage{multirow}   %multirow for format of table
\usepackage{tabularx} 	%表格排版格式控制
\usepackage{array}	%表格排版格式控制
\usepackage{hyperref} %超链接 \url{URL}
\usepackage{tikz}
\usepackage{dirtree}


\usetikzlibrary{intersections,
	positioning,
	petri,
	backgrounds,
	fit,
	decorations.pathmorphing,
	arrows,
	arrows.meta,
	bending,
	calc,
	intersections,
	through,
	backgrounds,
	shapes.geometric,
	quotes,
	matrix,
	trees,
	shapes.symbols,
	graphs,
	math,
	patterns,
	external}
\CTEXsetup[format+={\flushleft}]{section}

%%%% 设置图片目录
\graphicspath{{figure/}}

%%%% 段落首行缩进两个字 %%%%
\makeatletter
\let\@afterindentfalse\@afterindenttrue
\@afterindenttrue
\makeatother
\setlength{\parindent}{2em}  %中文缩进两个汉字位

%%%% 下面的命令重定义页面边距，使其符合中文刊物习惯 %%%%
\addtolength{\topmargin}{-54pt}
\setlength{\oddsidemargin}{0.63cm}  % 3.17cm - 1 inch
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textwidth}{14.66cm}
\setlength{\textheight}{24.00cm}    % 24.62

%%%% 下面的命令设置行间距与段落间距 %%%%
\linespread{1.4}
\setlength{\parskip}{0.5\baselineskip}
\geometry{left=1.6cm,right=1.8cm,top=2cm,bottom=1.7cm} %设置文章宽度
\pagestyle{plain} 		  %设置页面布局

%代码效果定义
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
	backgroundcolor=\color{white},   % choose the background color
	basicstyle=\footnotesize\ttfamily,      % size of fonts used for the code
	%stringstyle=\color{codepurple},
	%basicstyle=\footnotesize,
	%breakatwhitespace=false,         
	%breaklines=true,                 
	%captionpos=b,                    
	%keepspaces=true,                 
	%numbers=left,                    
	%numbersep=5pt,                  
	%showspaces=false,                
	%showstringspaces=false,
	%showtabs=false,        
	columns=fullflexible,
	breaklines=true,                 % automatic line breaking only at whitespace
	captionpos=b,                    % sets the caption-position to bottom
	tabsize=4,
	commentstyle=\color{mygreen},    % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	keywordstyle=\color{blue},       % keyword style
	stringstyle=\color{mymauve}\ttfamily,     % string literal style
	frame=L,
	xleftmargin = .05\textwidth,
	rulesepcolor=\color{red!20!green!20!blue!20},
	% identifierstyle=\color{red},
	language=c++,
}
 \author{\kaishu 郑华}
 \title{\heiti C\#笔记}
 
\begin{document}          %正文排版开始
 	\maketitle

\chapter{基础}
	\section{类型装换}

	\section{类}
	
	\section{继承}
	
	\section{多态}
	
	\section{预处理}
	
	\section{C\# 属性(Property)}
	
	\section{泛型}
	
	\section{反射}
	
\chapter{高级}
	\section{接口}
		
		\paragraph{IEumerable 接口}\fbox{IEnumerable}
		
			只包含一个方法\verb|GetEnumerator()|，它返回一个可用于循环访问集合的\verb|IEnumerator|对象，
			继承实现接口，完成该方法之后，就可以在调用时用\verb|foreach|了。
		
			\begin{lstlisting}
	public interface IEnumerable{
		// 返回一个循环访问集合的枚举器
		IEnumerator GetEnumerator();
	}
			\end{lstlisting}
		\paragraph{IEnumerator 接口} \fbox{IEnumerator}
			
			它是一个真正的集合访问器(枚举器)，没有它，就不能使用\verb|foreach语句|遍历集合或数组，因为只有\verb|IEnumerator|对象才能访问集合中的项，假如连集合中的项都访问不了，那么进行集合的循环遍历是不可能的事情了。
			
			\begin{lstlisting}
	public interface IEnumerator{
		// 获取集合中的当前元素
		object Current {get;}
		// 将枚举数推进到集合的下一个元素
		bool MoveNext();
		// 将枚举数设置为其初始位置，改位置位于集合中第一个元素之前
		void Reset()
	}
			\end{lstlisting}
			
			\subparagraph{参考}\url{https://www.cnblogs.com/aehyok/p/3642103.html}
				
			
	\section{枚举}
	
	\section{正则表达式}
	
	\section{文件操作}
	
	\section{属性}
	
	\section{集合}

	\newpage
 	\section{委托}
 		\paragraph{定义委托} \fbox{delegate  result-type  Identifier ([parameters]);}
 			\begin{itemize}
 				\item \verb|result-type|:返回值的类型，和\textbf{方法}的返回值类型\textbf{一致}
 				\item \verb|Identifier|:委托的名称
 				\item \verb|parameters|:参数，要引用的\textbf{方法}带的\textbf{参数}
 			\end{itemize}
 			
		 
		 \paragraph{实例化委托} \fbox{Identifier objectName = new Identifier(functionName)}
		 	  \begin{itemize}
		 	  	\item \textbf{Identifier} ：这个是委托名字
		 	  	\item \textbf{objectName} ：委托的实例化对象
		 	  	\item \textbf{functionName}：是该委托对象所指向的函数的名字
		 	  	
		 	  	 \verb|->|\textit{对于这个函数名要特别注意：定义这个委托对象肯定是在类中定义的，那么如果所指向的函数也在该类中，不管该函数是静态还是非静态的，那么就直接写函数名字就可以了；如果函数是在别的类里面定义的public、
		 	  	internal，但是如果是静态，那么就直接用类名.函数名，如果是非静态的，那么就类的对象名.函数名，这个函数名与该对象是有关系的，比如如果函数中出现了this，表示的就是对当前对象的调用。}
		 	  \end{itemize}
		 	 
		 \paragraph{委托推断}\fbox{Identifier  objectName  =  functionName}
		 
		 	当我们需要定义委托对象并实例化委托的时候，就\textbf{可以只传送函数的名称}，即函数的地址.
		 	
		 	这里面的\verb|functionName|与实例化委托的\verb|functionName|是一样的，没什么区别，满足上面的规则。
		 	
		 \paragraph{匿名委托} \fbox{ DelegateTest  anonDel = delegate([parameters]){//implements}}
		 	
		 	直接定义一个lambda来实现临时函数。
		 	
		 \paragraph{多播委托} \fbox{deleIntifier += functionX}
		 	
		 	\textit{前面使用的每个委托都只包含一个方法调用，调用委托的次数与调用方法的次数相同，如果要调用多个方法，就需要多次给委托赋值，然后调用这个委托。}
		 	\textbf{委托也可以包含多个方法，这时候要向委托对象中添加多个方法，这种委托称为多播委托}，\textit{多播委托有一个方法列表}，如果调用多播委托，就可以连续调用多个方法，即先执行某一个方法，等该方法执行完成之后再执行另外一个方法，这些方法的参数都是一样的，\textbf{这些方法的执行是在一个线程中执行的}，而不是每个方法都是一个线程，\textbf{最终将执行完成所有的方法}。
		 	
		 	多播委托包含一个逐个调用的委托集合。\textbf{如果通过委托调用的一个方法抛出了异常，整个迭代就会停止}。
		 
		 \paragraph{委托运算符} \fbox{= 、+=、-=}
		 	\subparagraph{=}\fbox{Identifier objName= new Identifier(functionName)}	 
		 		或者 \fbox{objName=functionName1}
		 		
		 		这里的“\verb|=|”号表示\textbf{清空} \verb|objectName| 的方法列表，然后将 \verb|functionName| \textbf{加入}到 \verb|objectName| 的\textbf{方法列表}中	 	
		 	
		 	\subparagraph{+=} \fbox{Identifier objName += new Identifier(functionName)}	 
		 		或者 \fbox{objName+=functionName1}
		 			 		
		 		这里的“\verb|+=|”号表示\textbf{在原有的方法列表不变的情况下}，将 \verb|functionName1|  \textbf{加入}到 \verb|objectName| 的方法列表中。可以在方法列表中加上多个相同的方法，执行的时候也会执行完所有的函数，哪怕有相同的，就会多次执行同一个方法。
		 		
		 	\subparagraph{-=}\fbox{Identifier objName -= new Identifier(functionName)}	 
		 		或者 \fbox{objName-=functionName1}
		 		
		 		这里的\verb|“-=”|号表示在 \verb|objectName| 的方法列表中减去一个\verb|functionName1|。\textbf{可以在方法列表中多次减去相同的方法}，\textit{减一次只会减一个方法}，\textit{如果列表中无此方法，那么减就没有意义，对原有列表无影响，也不会报错}。
		 		
	\section{事件}
		\subsection{自定义事件}
			\paragraph{声明一个委托}\fbox{Delegate result-type delegateName ([parameters]);}
			
				这个委托可以在类A内定义也可以在类A外定义
			
				\begin{lstlisting}
	public delegate void DelegateClick (int a);
				\end{lstlisting}
			\paragraph{声明一个基于某个委托的事件}\fbox{Event delegateName eventName;}
				
				eventName不是一个类型，而是一个具体的对象，这个具体的对象只能在类A内定义而不能在类A外定义
				
				\begin{lstlisting}
	 public event DelegateClick Click;
				\end{lstlisting}
				
			\paragraph{在类A中定义一个触发该事件的方法}\fbox{ReturnType  FunctionName（[parameters]）{...}}
				
				\begin{lstlisting}
	ReturnType  FunctionName（[parameters]）	
	{
		If(eventName != null)
		{
			eventName([parameters]);
			或者eventName.Invoke([parameters]);
		}
	}
	
	 public class butt
	 {
	        public event DelegateClick Click;
	        public void OnClick(int a)
	        {
	            if(Click != null)
	                Click.Invoke(a);
	               //Click(a);//这种方式也是可以的
	            MessageBox.Show("Click();");
	        }
	  }
				\end{lstlisting}
			
				触发事件之后，事件所指向的函数将会被执行。这种执行是通过事件名称来调用的，就像委托对象名一样的。
				
				触发事件的方法\textbf{只能在A类中定义}，事件的实例化，以及实例化之后的实现体都只能在A类外定义。
				
			\paragraph{初始化A类的事件}
				在类B中定义一个类A的对象，并且让类A对象的那个事件指向类B中定义的方法，这个方法要与事件关联的委托所限定的方法吻合。
			
				\begin{lstlisting}
	butt b = new butt();
	b.Click += new DelegateClick (Fm_Click); //事件是基于委托的，所以委托推断一样适用，下面的语句一样有效：b.Click += Fm_Click;
				\end{lstlisting}
				
			\paragraph{触发A类的事件}
				在B类中去调用A类中的触发事件的方法：用A类的对象去调用A类的触发事件的方法。
				\begin{lstlisting}
	b.OnClick(10000);    
				\end{lstlisting}
			
		\subsection{控件事件}
			\paragraph{控件事件委托 EventHandler}\fbox{Public delegate void EventHandler(object sender,EventArgs e);}
			
			\paragraph{委托EventHandler 参数}
				
				一般\textit{第一个参数}都是\verb|object sender|，\textit{第二个参数}可以是\textbf{任意类型}，不同的委托可以有不同的参数，\textbf{只要它派生于EventArgs即可}。
			
			\paragraph{实例}
				\begin{lstlisting}
		// 第1步：定义参数
	    public class TimeInfoEventArgs : EventArgs
	    {
	        public TimeInfoEventArgs(int hour,int minute,int second)
	        {
	            this.hour = hour;
	            this.minute = minute;
	            this.second = second;
	        }
	        public readonly int hour;
	        public readonly int minute;
	        public readonly int second;
	    }
	
		// 第2步：定义委托
	    // 定义名为SecondChangeHandler的委托，封装不返回值的方法，
	    // 该方法带参数，一个clock类型对象参数，一个TimeInfoEventArgs类型对象
	    public delegate void SecondChangeHandler(object clock, TimeInfoEventArgs timeInformation);
	
		
		// 第3步：定义事件发送者
	    // 被其他类观察的钟（Clock）类，该类发布一个事件：SecondChange。观察该类的类订阅了该事件。
	    public class Clock
	    {
	        // 代表小时，分钟，秒的私有变量
	        int _hour;
	        public int Hour
	        {
	            get { return _hour; }
	            set { _hour = value; }
	        }
	        private int _minute;
	        public int Minute
	        {
	            get { return _minute; }
	            set { _minute = value; }
	        }
	        private int _second;
	        public int Second
	        {
	            get { return _second; }
	            set { _second = value; }
	        }
	        
	        // 要发布的事件
	        public event SecondChangeHandler SecondChange;
	
	        // 触发事件的方法
	        protected void OnSecondChange(object clock,TimeInfoEventArgs timeInformation)
	        {
	            // Check if there are any Subscribers
	            if (SecondChange != null)
	            {
	                // Call the Event
	                SecondChange(clock, timeInformation);
	            }
	        }
	        // 让钟（Clock）跑起来，每隔一秒钟触发一次事件
	        public void Run()
	        {
	            for (; ; )
	            {
	                // 让线程Sleep一秒钟
	                Thread.Sleep(1000);
	                // 获取当前时间
	                System.DateTime dt = System.DateTime.Now;
	                // 如果秒钟变化了通知订阅者
	                if (dt.Second != _second)
	                {
	                    // 创造TimeInfoEventArgs类型对象，传给订阅者
	                    TimeInfoEventArgs timeInformation =new TimeInfoEventArgs(dt.Hour, dt.Minute, dt.Second);
	                    
	                    // 通知订阅者
	                    OnSecondChange(this, timeInformation);
	                }
	                // 更新状态信息
	                _second = dt.Second;
	                _minute = dt.Minute;
	                _hour = dt.Hour;
	            }
	        }
		}
		
	/* ======================= Event Subscribers =============================== */
		    // 一个订阅者。DisplayClock订阅了clock类的事件。它的工作是显示当前时间。
		    public class DisplayClock
		    {
		        // 传入一个clock对象，订阅其SecondChangeHandler事件
		        public void Subscribe(Clock theClock)
		        {
		            theClock.SecondChange += new SecondChangeHandler(TimeHasChanged);
		        }
		        
		        // 实现了委托匹配类型的方法
		        public void TimeHasChanged(object theClock, TimeInfoEventArgs ti)
			      {
			          Console.WriteLine("Current Time: {0}:{1}:{2}",
			             ti.hour.ToString(),
			             ti.minute.ToString(),
			             ti.second.ToString());
			      }
		    }
		    
		    // 第二个订阅者，他的工作是把当前时间写入一个文件
		    public class LogClock
		    {
		        public void Subscribe(Clock theClock)
		        {
		            theClock.SecondChange += new SecondChangeHandler(WriteLogEntry);
		        }
		        // 这个方法本来应该是把信息写入一个文件中
		        // 这里我们用把信息输出控制台代替
		        public void WriteLogEntry(object theClock, TimeInfoEventArgs ti)
		        {
		            Clock a = (Clock)theClock;
		            Console.WriteLine("Logging to file: {0}:{1}:{2}",
		               a.Hour.ToString(),
		               a.Minute.ToString(),
		               a.Second.ToString());
		        }
		    }
		    
 	 /* ======================= Test Application =============================== */
		    // 测试拥有程序
		    public class Test
		    {
		        public static void Main()
		        {
		            // 创建clock实例
		            Clock theClock = new Clock();
		            // 创建一个DisplayClock实例，让其订阅上面创建的clock的事件
		            DisplayClock dc = new DisplayClock();
		            dc.Subscribe(theClock);
		            // 创建一个LogClock实例，让其订阅上面创建的clock的事件
		            LogClock lc = new LogClock();
		            lc.Subscribe(theClock);
		            // 让钟跑起来
		            theClock.Run();
		        }
		    }
				\end{lstlisting}
			
		\url{https://blog.csdn.net/chaixinke/article/details/45396269}
		
		
\end{document} 
 		    