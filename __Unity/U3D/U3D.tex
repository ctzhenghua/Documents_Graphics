\documentclass[UTF8,a4paper,12pt]{ctexbook} 

\usepackage{graphicx}%学习插入图
\usepackage{verbatim}%学习注释多行
\usepackage{booktabs}%表格
\usepackage{geometry}%图片
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}%代码
\usepackage{xcolor}  %颜色
\usepackage{enumitem}%列表格式
\setenumerate[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\setitemize[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\setdescription{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\usepackage{tcolorbox}
\usepackage{algorithm}  %format of the algorithm
\usepackage{algorithmic}%format of the algorithm
\usepackage{multirow}   %multirow for format of table
\usepackage{tabularx} 	%表格排版格式控制
\usepackage{array}	%表格排版格式控制
\usepackage{hyperref} %超链接 \url{URL}
\usepackage{tikz}
\usepackage{dirtree}


\usetikzlibrary{intersections,
	positioning,
	petri,
	backgrounds,
	fit,
	decorations.pathmorphing,
	arrows,
	arrows.meta,
	bending,
	calc,
	intersections,
	through,
	backgrounds,
	shapes.geometric,
	quotes,
	matrix,
	trees,
	shapes.symbols,
	graphs,
	math,
	patterns,
	external}
\CTEXsetup[format+={\flushleft}]{section}

%%%% 设置图片目录
\graphicspath{{figure/}}

%%%% 段落首行缩进两个字 %%%%
\makeatletter
\let\@afterindentfalse\@afterindenttrue
\@afterindenttrue
\makeatother
\setlength{\parindent}{2em}  %中文缩进两个汉字位

%%%% 下面的命令重定义页面边距，使其符合中文刊物习惯 %%%%
\addtolength{\topmargin}{-54pt}
\setlength{\oddsidemargin}{0.63cm}  % 3.17cm - 1 inch
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textwidth}{14.66cm}
\setlength{\textheight}{24.00cm}    % 24.62

%%%% 下面的命令设置行间距与段落间距 %%%%
\linespread{1.4}
\setlength{\parskip}{0.5\baselineskip}
\geometry{left=1.6cm,right=1.8cm,top=2cm,bottom=1.7cm} %设置文章宽度
\pagestyle{plain} 		  %设置页面布局

%代码效果定义
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
	backgroundcolor=\color{white},   % choose the background color
	basicstyle=\footnotesize\ttfamily,      % size of fonts used for the code
	%stringstyle=\color{codepurple},
	%basicstyle=\footnotesize,
	%breakatwhitespace=false,         
	%breaklines=true,                 
	%captionpos=b,                    
	%keepspaces=true,                 
	%numbers=left,                    
	%numbersep=5pt,                  
	%showspaces=false,                
	%showstringspaces=false,
	%showtabs=false,        
	columns=fullflexible,
	breaklines=true,                 % automatic line breaking only at whitespace
	captionpos=b,                    % sets the caption-position to bottom
	tabsize=4,
	commentstyle=\color{mygreen},    % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	keywordstyle=\color{blue},       % keyword style
	stringstyle=\color{mymauve}\ttfamily,     % string literal style
	frame=L,
	xleftmargin = .079\textwidth,
	rulesepcolor=\color{red!20!green!20!blue!20},
	% identifierstyle=\color{red},
	language=c++,
}
 \author{\kaishu 郑华}
 \title{\heiti U3D笔记}
 
\begin{document}          %正文排版开始
 	\maketitle
 	\tableofcontents

\chapter{基础}
	入门参考：\url{https://unity3d.com/cn/learn/tutorials}
	
	\section{如何将脚本与具体对象绑定}
		\begin{enumerate}
			\item 右键\verb|asset|文件夹，创建C\#脚本
			\item 编写脚本
			\item 将\verb|asset |中的脚本拖拽到 \verb|hiearch |视图中的\verb|MainCamera |中
			\item 如果脚本是作用于场景中的某个物体，\textbf{则将该脚本拖拽到该物体上}
		\end{enumerate}
	
	\section{序列化-  [SerializedField]}
		\textit{通常情况下}，GameObject上挂的MonoBehaviour脚本中的\textbf{私有变量}\textit{不会显示在Inspector面板上}，即不会被序列化。
		
		\textbf{但如果指定了SerializedFiled特性}，就可以被序列化了。
		
		\begin{lstlisting}
	public class Test : MonoBehaviour 
	{
		public string Name;
		[SerializeField]
		private int Hp; 
	}
		\end{lstlisting}
		
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.8]{SerilizedFiled.jpg}
			\caption{序列化操作 -在Inspector上显示}
		\end{figure}
	
	\section{常用技巧}
		\begin{itemize}
			\item \verb|ctrl + d| 复制
			\item \verb|shift + 鼠标 | 等比例缩放 
			\item \verb|shift + alt + 鼠标 | 原地等比例缩放
			\item \verb|在Unity 编辑器中输入汉字 | 需要借助其他文本拷贝粘贴
			\item \verb|q、w、e、r、t |在操作UI时尽量使用 T，以避免z轴发生的变化 
		\end{itemize}
	
	\section{MonoBehaviour 生命周期、渲染管线}
		
		\subsection{脚本渲染流程}
			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.44]{scriptLifeCircle.jpg}
				\caption{脚本生命周期核心方法}
			\end{figure}
			
			\clearpage
			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.78]{LifeCicle.png}
				\caption{简要核心方法}
			\end{figure}
		
		update：当其\textbf{所在的物体}属于未激活的话（\verb|active为false|），\textit{该物体上所有脚本中包含的协程代码都是不会被执行的}。
		\subsection{核心方法}
			\begin{enumerate}
				\item \verb|Reset |:
				\item \verb|Awake |:脚本唤醒函数，\textbf{当游戏对象被创建的时候}，\textit{游戏对象}\textbf{绑定的脚本会在该帧(Frame)内}\textit{执行Awake() 函数}，\textbf{无论}脚本是否处于激活(\textbf{enable})状态。
				\item \verb|OnEnable |:激活函数，当脚本被激活时调用。
				\item \verb|Start |:该函数在脚本被激活的时候执行，位于Awake之后，该函数同样也是在游戏对象被创建的帧里，\textbf{不同的是}，如果脚本处于不激活状态(\verb|MonoBehaviour.enable = false|), start 函数是不会执行的。
				\item \verb|FixedUpdate |:
				\item \verb|yield WaitForFixedUpdate |:
				\item \verb|OnTriggerXXX |:
				\item \verb|Update |:\textbf{只要处于激活状态的脚本}，\textit{都会在每一帧里调用Update() 函数}，该函数也是最为常用的一个函数，用来更新逻辑。
				\item \verb|LateUpdate |:延迟更新函数
				\item \verb|OnWillRenderObject |:
				\item \verb|OnGUI |:绘制界面函数。 
				\item \verb|yield WaitForEndOfFrame |:
				\item \verb|OnDisable |:
				\item \verb|OnDestroy |:在当前脚本销毁时调用该函数。
			\end{enumerate}
		
	\section{Unity 委托}
		
		\paragraph{定义}\verb|public delegate void MyDelegate(int num);|
		
			\textbf{委托}就是\verb|C#|封装的\textbf{C++的函数指针}。
			
			定义一个委托MyDelegate，如同定义一个类一样，此时的委托没有经过实例化是无法使用的，而他的实例化必须接收一个返回值和参数都与他等同的函数，此处的委托MyDelegate只能接收返回值为void，参数为一个int的函数
			
		\paragraph{实例化委托}：\verb|MyDelegate _MyDelegate=new MyDelegate(TestMod);|
			
			以\verb|TestMod|函数实例化一个\verb|MyDelegate|类型的委托\verb|_MyDelegate|，此处\verb|TestMod|函数的定义就应如下：
				
			\verb|public void TestMod(int _num);|
				
			之后调用\verb|_MyDelegate(100)|时就完全等同于调用\verb|TestMod(100)|
		
		
		
	\section{Unity 协程}
		\subsection{开启方式}
			协程：协同程序，在主程序运行的同时，开启另外一段逻辑处理，来协同当前程序的执行。
			
			\paragraph{StartCoroutine(string MethodName)}
				\begin{itemize}
					\item 参数是方法名					
					\item 形参方法可以有返回值
				\end{itemize}
			
			\paragraph{StartCoroutine(IEnumerator method)}
				\begin{itemize}
					\item 参数是方法名(\verb|TestMethod()|),方法中\textbf{可以包含多个参数}
					\item \verb|IEnumrator| 类型的方法不能含有\verb|ref或者out| 类型的参数，\textbf{但可以含有被传递的引用}
					\item \textbf{必须有有返回值}，且返回值类型为\verb|IEnumrator|,返回值使用（\textit{yield retuen +表达式或者值}，或者 \textit{yield break}）语句	
			\end{itemize}
		
		\subsection{终止方式}
			\paragraph{StopCoroutine(string MethodName)}
				只能终止指定的协程
			
			\paragraph{StopAllCoroutine()}
				终止所有协程
				
		\subsection{yield 方式}
			\paragraph{yield return}
				挂起，\textbf{程序遇到}\verb|yield|\textbf{关键字时会被挂起}，暂停执行，\textbf{等待条件满足时从当前位置继续执行}
				
				\begin{itemize}
					\item \verb|yield return 0| or \verb|yield return null|:程序在下一帧中从当前位置继续执行
					\item \verb|yield return 1,2,3,......|: 程序等待1，2，3...帧之后从当前位置继续执行
					\item \verb|yield return new WaitForSeconds(n)|:程序等待n秒后从当前位置继续执行
					\item \verb|yield new WaitForEndOfFrame()|:在所有的渲染以及GUI程序执行完成后从当前位置继续执行
					\item \verb|yield new WaitForFixedUpdate()|:所有脚本中的FixedUpdate()函数都被执行后从当前位置继续执行
					\item \verb|yield return WWW()|:等待一个网络请求完成后从当前位置继续执行
					\item \verb|yield return StartCoroutine()|:等待一个协程执行完成后从当前位置继续执行
				\end{itemize}
			
			\paragraph{yield break}
				如果使用\verb|yield break|语句，将会导致\textbf{如果协程的执行条件不被满足}，\textit{不会从当前的位置继续执行程序，而是直接从当前位置跳出函数体，回到函数的根部}
				
				\color{blue}相当于：\textbf{return; + 暂停}\color{black}
				
		\subsection{执行原理}
			协程函数的返回值是\verb|IEnumerator|,它是一个迭代器，\textbf{可以把它当成执行一个序列的某个节点的指针}，它提供了两个重要的接口，分别是\verb|Current|(返回当前指向的元素)和\verb|MoveNext()|(将指针向后移动一个单位，\textit{如果移动成功，则返回true})
			
			\verb|yield|关键词\textbf{用来声明序列中的下一个值或者是一个无意义的值}，如果使用\verb|yield return x|(x是指一个具体的对象或者数值)的话，那么\verb|MoveNext|返回为\verb|true|并且\verb|Current|被赋值为\verb|x|,如果使用\verb|yield break|使得\verb|MoveNext()|返回为\verb|false|
			
			如果\verb|MoveNext|函数返回为\verb|true|\textbf{意味着协程的执行条件被满足，则能够从当前的位置继续往下执行}。否则不能从当前位置继续往下执行。	

	\paragraph{委托+协程}
		\url{https://blog.csdn.net/qq992817263/article/details/51514449}
		
		\begin{itemize}
			\item 实现延时
			\item 实现给定函数传参
			\item 实现特定功能
		\end{itemize}
	
		\begin{lstlisting}
	// 延时执行

	// <param name="action">执行的委托</param>
	// <param name="obj">委托的参数</param>
	// <param name="delaySeconds">延时等待的秒数</param>
	public IEnumerator DelayToInvokeDo(Action<GameObject> action, GameObject obj,float delaySeconds)
	{
		yield return new WaitForSeconds(delaySeconds); // delaySeconds 后执行
		action(obj); // 特定功能
	}
	// 使用例子
	StartCoroutine(
		DelayToInvokeDo(
			delegate(GameObject task) {
				task.SetActive(true);
				task.transform.position = Vector3.zero;
				task.transform.rotation = Quaternion.Euler(Vector3.zero);
				task.doSomethings();
			},
			/*传参*/GameObject.Find("task1"),
			1.5f)/*End 匿名委托*/
		);/*End 协程初始*/
		\end{lstlisting}
		
\chapter{事件}
	\section{必然事件}
		继承自\verb|MonoBehaviour 类|后，自动会\textbf{按序}\textit{提供以下方法}:
		
		\begin{itemize}
			\item \verb|Awake()|:在加载场景时运行，用于在游戏开始前完成变量初始化、以及游戏状态之类的变量。
			\item \verb|Start()|:在第一次启动游戏时执行，用于游戏对象的初始化，在\verb|Awake() |函数之后。
			\item \verb|Update()|:是在每一帧运行时必须执行的函数，用于更新场景和状态。
			\item \verb|FixedUpdate()|:与\verb|Update() |函数相似，但是在固定的物理时间后间隔调用，用于物理状态的更新。
			\item \verb|LateUpdate()|:是在\verb|Update() |函数执行完成后再次被执行的，有点类似收尾的东西。 
		\end{itemize}
			
	\section{碰撞事件}
		U3D 的碰撞检测。具体分为三个部分进行实现，碰撞发生进入时、碰撞发生时和碰撞结束，理论上不能穿透
		
		\begin{itemize}
			\item \verb|OnCollisionEnter(Collision collision)| 当碰撞物体间刚接触时调用此方法
			\item \verb|OnCollisionStay(Collision collision)| 当发生碰撞并保持接触时调用此方法
			\item \verb|OnCollisionExit(Collision collision)| 当不再有碰撞时，既从有到无时调用此函数
		\end{itemize}

	\section{触发器事件}
		类似于 红外线开关门， 有个具体的范围，然后进入该范围时，执行某种动作，离开该范围时执行某种动作。类似于物体于一个透明的物体进行碰撞检测，理论上需要穿透，在U3D 中通过勾选 \verb|Is Trigger| 来确定该物体是可以穿透的。
		
		\begin{itemize}
			\item \verb|OnTriggerEnter() | 当其他碰撞体进入触发器时，执行该方法
			\item \verb|OnTriggerStay() | 当其他碰撞体停留在该触发器中，执行该方法
			\item \verb|OnTriggerExit() | 当碰撞体离开该触发器时，调用该方法
		\end{itemize}
		

\chapter{实体-人物、物体、组件}
		
	\section{实体类} \verb|GameObject 类|,游戏基础对象，用于填充世界。
		\paragraph{复制}
			\verb|Instantiate(GameObject)| 或 \verb|Instantiate(GameObject, position, rotation)|
			
			\begin{itemize}
				\item \verb|GameObject |指生成克隆的\textbf{游戏对象}，也可以是\textbf{Prefab 的预制品}
				\item \verb|position |克隆对象的初始位置，类型为\verb|Vector3|
				\item \verb|rotation |克隆对象的初始角度，类型为\verb|Quaternion|
			\end{itemize} 
		
		\paragraph{销毁}
			\verb|Destroy(GameObject xx)- 立即销毁 |或 \verb|Destroy(GameObject xx, Time time)- 几秒后销毁|
			
		\paragraph{可见否}
			通过设置该参数调整该实体是否可以在游戏中显示，具体设置方法为\verb|gameObject.SetActive(true) 为可以显示，false 则隐藏|
		
		\paragraph{游戏中获取}
			\begin{enumerate}
				\item 在整个场景中寻找名为xx的游戏对象，并赋予obj 变量
					
					\verb|obj = GameObject.Find("xx");|
					
				\item 当需要获取某个\verb|gameObject| 下的组件时,使用\verb|Transform.Find.GetComponent|
					
					\verb|gameObjVar1.transform.Find("ImageItemIcon/TextMonthCardLeftDays").\label{GetComponen\left( }t<Text>().text = "xx";|
				
				\item 但是设置为激活状态则需要如下通过\verb|gameObject|进行设置。
				
					\verb|obj = gameObjVar1.transform.Find("xx/xx").gameObject.SetActive(true);|
			\end{enumerate}
	\section{Prefabs -预设体}
		prefabs基础：\url{https://www.cnblogs.com/yuyaonorthroad/p/6107320.html}
		
		动态加载Prefabs：\url{https://blog.csdn.net/linshuhe1/article/details/51355198}
		
		在进行一些功能开发的时候，我们常常将一些\textbf{能够复用的对象}制作成.\textbf{prefab的预设物体}，然后将预设体存放到Resources目录之下，使用时再动态加载到场景中并进行实例化。例如：子弹、特效甚至音频等，都能制作成预设体。
		
		\subparagraph{概念} 组件的集合体, 预制物体可以实例化成游戏对象.
		\subparagraph{作用} 可以重复的创建具有相同结构的游戏对象。	
		
		\subsection{预设动态加载到场景}
			\paragraph{预设体资源加载}\verb|->|
			
				假设预设体的位置为下图所示
				\begin{figure}[H]
					\centering
					\includegraphics[scale=0.6]{Prefab-1.png}
					\caption{Prefab 资源位置}
				\end{figure}
			
				\begin{lstlisting}[xleftmargin = .079\textwidth, frame = L]
	//加载预设体资源
	GameObject hp_bar = (GameObject)Resources.Load("Prefabs/HP_Bar");				
				\end{lstlisting}
				
			通过上述操作，实现从资源目录下\textbf{载入}\verb|HP_Bar.prefab|\textbf{预设体}，\textbf{用}一个\verb|GameObject|\textbf{对象来存放}，此时该预设物体并未真正载入到场景中，因为还未进行实例化操作。
			
			\paragraph{预设体实例化}\verb|->|
			
				实例化使用的是\verb|MonoBehaviour.Instantiate|函数来完成的，\textbf{其实质就是从预设体资源中克隆出一个对象}，它\textit{具有与预设体完全相同的属性}，并且被加载到当前场景中
				
				完成以上代码之后，在当前场景中会出现一个实例化之后的对象，并且其父节点默认为当场的场景最外层，如下图所示。
					\begin{figure}[H]
						\centering
						\includegraphics[scale=0.8]{Prefab-2.png}
						\caption{Prefab 实例后位置}
					\end{figure}
				
			\paragraph{实例化对象属性设置}\verb|->|
				
				完成上述步骤之后，我们已经可以在场景中看到实例化之后的对象，但是通常情况下我们\textbf{希望}我们的\textbf{对象之间层次感分明}，而且这样也方便我们进行对象统一管理，而不是在Hierarchy中看到一大堆并排散乱对象，所以我们\textbf{需要为对象设置名称以及父节点等属性}。
			
				\verb|-->Notice：|常见错误：对\textbf{未初始化}的\verb|hp_bar|进行属性设置，\textbf{设置之后的属性在实例化之后无法生效}。这是\textit{因为我们最后在场景中}\textbf{显示的其实并非实例化前的资源对象}，\textbf{而是一个克隆对象}，\color{blue}\textit{所以假如希望设置的属性在最后显示出来的对象中生效，我们需要对实例化之后的对象进行设置}。\color{black}
			
			  正确的设置代码如下，可以看到\textbf{实例化对象}已成功挂在到\textbf{父节点Canvas}上，在层次视图效果如下图所示：
			  	\begin{lstlisting}[xleftmargin = .079\textwidth, frame = L]
	GameObject hp_bar = (GameObject)Resources.Load("Prefabs/HP_Bar");
	
	//搜索画布的方法！
	GameObject mUICanvas = GameObject.Find("Canvas");
	hp_bar = Instantiate(hp_bar);
	hp_bar.transform.parent = mUICanvas.transform;
			  	\end{lstlisting}
			  	
			  	\begin{figure}[H]
			  		\centering
			  		\includegraphics[scale=0.8]{Prefab-3.png}
			  		\caption{Prefab对象 设置父子关系}
			  	\end{figure}
		  	
		  		\subparagraph{简化写法}上述实例步骤与属性设置代码可以简化为
		  			\begin{lstlisting}[xleftmargin = .079\textwidth, frame = L]
	GameObject hp_bar = (GameObject)Instantiate(Resources.Load("Prefabs/HP_Bar"));
	GameObject mUICanvas = GameObject.Find("Canvas");
	hp_bar.transform.parent = mUICanvas.transform;	  				
		  			\end{lstlisting}
		  	
		  	\paragraph{预制体添加脚本}
		  		在预制体上不能直接添加脚本，首先需要将其拖入场景，然后再对其操作，这个时候可以添加脚本，添加组件等，在完成这些操作后，在Inspector 选项中选中 Apply,然后删除其在场景中的刚才拖过来的，即可。		
	\section{获取实体上的组件}
		\paragraph{调用方式}\verb|GameObject.GetComponent<Type>().xx = xx;|
			
			\begin{itemize}
				\item \verb|cube1.GetComponent<RigidBody>().mass = 20;| //设置重量
				\item \verb|cube1.GetComponent<BoxCollider>().isTrigger = true;| //\textbf{开启Trigger 穿透方式}检测
				\item \verb|cube2.GetComponent<Test>().enable = false;| //\textbf{禁用Test脚本}
			\end{itemize}
	
	\section{物理作用实体类} \verb|Rigidbody 类|，一种特殊的游戏对象，该类对象可以在物理系统的控制下来运动。
		\paragraph{AddForce()}
			此方法调用时\verb|rigidBody.AddForce(1, 0, 0);|，会施加给刚体一个瞬时力，在力的作用下，会产生一个加速度进行运动。
			
		\paragraph{AddTorque()}
			给刚体添加一个扭矩。
			
		\paragraph{Sleep()}
			使得刚体进入休眠状态，且至少休眠一帧。类似于暂停几帧的意思，这几帧不进行更新、理论位置也不进行更新。
			
		\paragraph{WakeUp()}
			使得刚体从休眠状态唤醒。
		
\chapter{世界空间相关3D基础}
	\section{Transform 类}
		\url{https://blog.csdn.net/yangmeng13930719363/article/details/51460841}
		\subsection{位置}
				transform.position = new Vector3(1, 0, 0);
		\subsection{旋转}	
				transform.Rotate(x, y, z);
				
				transform.eulerAngles = new Vector3(x, y, z);	
		\subsection{缩放}
				transform.localScale(x, y, z); // 基准为1、1、1， 数为缩放因子。	
		\subsection{平移}
				transform.Translate(x, y, z); 
		\subsection{Transform.localPosition}
			\verb|position|是世界坐标中的位置，可以理解为绝对坐标 
			
			\verb|localPosition|是\textbf{相对于父对象的位置}，是相对坐标，既父级窗体为原点坐标
		\subsection{注意}
			在变化的过程中需要乘以 Time.deltaTime ,否则会出现大幅不连贯的画面。
	
	\section{摄像机 -Camera}
		\subsection{Clear Flags}
			清除标记。决定屏幕的哪部分将被清除。一般用户使用对台摄像机来描绘不同游戏对象的情况，有3中模式选择：
			\begin{itemize}
				\item \verb|Skybox|：天空盒。默认模式。在屏幕中的空白部分将显示当前摄像机的天空盒。如果当前摄像机没有设置天空盒，会默认用Background色。
				\item \verb|Solid Color|：纯色。选择该模式屏幕上的空白部分将显示当前摄像机的background色。
				\item \verb|Depth only|：仅深度。该模式用于游戏对象不希望被裁剪的情况。
				\item \verb|Dont Clear|：不清除。该模式不清除任何颜色或深度缓存。其结果是，每一帧渲染的结果叠加在下一帧之上。一般与自定义的shader配合使用。
			\end{itemize}
		\subsection{Culling Mask -剔除遮罩} 
			剔除遮罩，选择所要显示的\verb|layer|, \textbf{摄像机将看到勾选的层，忽略未被勾选的层。}
		
		\subsection{Projection -透视模式}
			\paragraph{透视}
				摄像机模式，\textbf{截锥体}
				
			\paragraph{正交}
				前后显示一样，不存在远小近大的样子。\textbf{长方体}
				
		\subsection{Clipping Planes -裁剪模式}
			剪裁平面。摄像机开始渲染与停止渲染之间的距离。
			
		\subsection{Viewport Rect}
			标准视图矩形。用四个数值来控制摄像机的视图将绘制在屏幕的位置和大小，使用的是屏幕坐标系，数值在0~1之间。坐标系原点在左下角。
			
		\subsection{Depth -控制渲染顺序}
			深度。\textbf{用于控制摄像机的渲染顺序}，\textbf{较大}值的摄像机将\textbf{被}渲染\textit{在}\textbf{较小}值的摄像机\textbf{之上}。
			
		\subsection{Rendering Path -渲染路径}
			渲染路径。\textbf{用于指定摄像机的渲染方法}。
			
			\verb|Use Player Settings|：使用\verb|Project Settings-->Player|中的设置。
			
			\verb|Forward|：\textbf{快速渲染}。摄像机将所有游戏对象将按每种材质一个通道的方式来渲染。
			
			\verb|Defferred|: \textbf{延迟光照}
			\verb|Legacy Vertex Lit|：\textbf{顶点光照}。摄像机将对所有的游戏对象座位顶点光照对象来渲染。
			
			\verb|Legacy Deferred Lighting|：\textbf{延迟光照}。摄像机先对所有游戏对象进行一次无光照渲染，用屏幕空间大小的Buffer保存几何体的深度、法线已经高光强度，生成的Buffer将用于计算光照，同时生成一张新的光照信息Buffer。最后所有的游戏对象会被再次渲染，渲染时叠加光照信息Buffer的内容。
			
		\subsection{Target Texture -目标纹理}
			用于将摄像机视图\textbf{输出并渲染到}\textit{一张贴图}\underline{sss}。一般用于制作导航图或者画中画等效果。
			
		\subsection{HDR -高动态光照渲染}
			高动态光照渲染。用于启用摄像机的高动态范围渲染功能。
	
	\section{3D模型}
		\subsection{Mesh}
		
		\subsection{Texture}
				
		\subsection{Material}
			尽管是近似的灰色，也同样会因为材质的不同显示出不同的效果，入灰色T恤衫和灰色不锈钢，首先是他们对光照的反应不同（漫反射、平面），其次是表面的各种属性。
			
		\subsection{骨骼动画}
	
	
	
\chapter{键盘鼠标控制}
	\section{普通按键 -keyDown(KeyCode xx)}
		\paragraph{方式一}
		
			\begin{itemize}
				\item 定义按键码：\verb|KeyCode keycode;|
				\item 判断键是否被按下：\verb|if(Input.GetKeyDown(keycode)){}|
				\item 在\verb|Inspirit -> Keycode |指定关联按键
			\end{itemize}
	
		\paragraph{方式二}
			\begin{itemize}
				\item 在\verb|Update| 中更新添加如下代码
				\item \verb|if(Input.GetKeyDown(KeyCode.UpArrow))| 
				\item \verb|KeyCode.xx |包括了键盘所有的按键，常用的AWSD 如下，鼠标同(Input.GetMouseButtonDown(0) 0左键，1右键)
					\begin{itemize}
						\item \verb|if (Input.GetKeyDown(KeyCode.S)) | 按下S键
						\item \verb|if (Input.GetKey(KeyCode.S))| 按住S键
						\item \verb|if (Input.GetKeyUp(KeyCode.W)) | 抬起S键
					\end{itemize}
			\end{itemize}
		
	\section{根据输入设备 -getAxis()}
		参数分为两类： 
		\paragraph{一、触屏类}
		 	\begin{enumerate}
			 	\item \verb|Mouse X| 鼠标沿屏幕X移动时触发 
			 	\verb|Mouse Y| 鼠标沿屏幕Y移动时触发 
			 	\verb|Mouse ScrollWheel |鼠标滚轮滚动是触发 
		 	\end{enumerate}
			
			\begin{lstlisting}
	float mouseX = Input.GetAxis("Mouse X");
	float mouseY = Input.GetAxis("Mouse Y");
	
	transform.Rotate(Vector3.Up * mouseX * rotateSpeed); // 根据具体需求进行操作
			\end{lstlisting}
		
		\paragraph{二、键盘类}
		 	\begin{enumerate}
		 		\item Vertical 键盘按上或下键时触发 
		 		\item Horizontal 键盘按左或右键时触发
		 	\end{enumerate}
		 	
		 	\begin{lstlisting}
	float horizontal = Input.GetAxis("Horizontal");
	float vertical = Input.GetAxis("Vertical");
	
	Vector3 desPos = (transform.forward * vertical  + transform.right * horizontal) * Time.deltaTime * moveSpeed;
	
	_rigidBody.position += desPos;
		 	\end{lstlisting}
		\textbf{返回值}是一个数，正负代表方向
			
\chapter{时间}
 	\section{Time 类}
 		该类是 U3D 在游戏中获取时间信息的接口类。常用变量如下：
 		
 		\begin{table}[H]
 			\centering
 			\caption{时间变量对照表}
 			\begin{tabular}{m{4cm}|m{10cm}}
 				\toprule
 					变量名 & 意义\\
 				\midrule
 					time & 单位为秒 \\
 					\verb|deltaTime|     & 从上一帧到当前帧消耗的时间 \\
 					fixedTime     & 最近FixedUpdate 的时间，从游戏开始计算 \\
 					\verb|fixedDeltaTime|     & 物理引擎和FixedUpdate 的更新时间间隔 \\
 					timeSceneLevelLoad     & 从当前Scene 开始到目前为止的时间 \\
 					realTimeSinceStartup     & 程序已经运行的时间 \\
 					\verb|frameCount|     & 已经渲染的帧的总数 \\
 				\bottomrule 
 			\end{tabular}
 		\end{table}
 		 		

\chapter{数学}
	\section{Random 类}
		随机数类
		
	\section{Mathf 类}
		数学类
	
	
\chapter{光照}
	\section{光照}
		
	\section{烘培}
		\paragraph{简介}
			只有静态场景才能完成烘培（Bake）操作，其目的是在游戏编译阶段完成光照和阴影计算，然后以贴图的形式保存在资源中，以这种手段避免在游戏运行中计算光照而带来的CPU和GPU损耗。
			
			\begin{itemize}
				\item \textbf{如果不烘培}：游戏运行时，这些阴影和反光是由CPU和GPU计算出来的。
				\item \textbf{如果烘焙}：游戏运行时，直接加载在编译阶段完成的光照和阴影贴图，这样就不用再进行计算，节约资源。
			\end{itemize}
		
		\paragraph{流程}
	
	
\chapter{寻路}
	\section{简介}
		NPC 完成自动寻路的功能。
		
	\section{流程}
		\begin{itemize}
			\item 将静态场景调至(Navigation Static)
			\item 烘焙
			\item 添加 \verb|Navigation Mesh Agent| 寻路组件
			\item 在脚本中设置组件的目标地址，添加目标
		\end{itemize}
	
\chapter{UGUI}
	在脚本中使用时记得加上\verb|using UnityEngine.UI |
	
	\url{https://blog.csdn.net/wangmeiqiang/article/category/6364468}
	
	\section{Spirit}
		在UI系统中，\textbf{所有的图片的显示}\underline{都必须}\textit{通过Spirit。}
		
		如果建立工程时选择的是2D工程，那么导入的所有图片会自动设置为\textit{Spirit。}
		
		如果建立工程时选择的是3D工程，那么导入的所有图片需要手动的设置为\textit{Spirit。}\verb|Inspector -> Texture Type -> Spirit(2D and UI)|,最后点击Apply 保存更改。
	
	\section{Canvas}
		Canvas画布\textbf{是承载所有UI元素的区域}。\verb|Canvas|实际上\textbf{是一个游戏对象}上\textbf{绑定了Canvas组件}。
		
		\textbf{所有的UI元素}都\textbf{必须是Canvas的子对象}。如果场景中没有画布，那么我们创建任何一个UI元素，都会自动创建画布，并且将新元素置于其下。
		
		在Canvas的\verb|Render Mode|中有三个选择：
			\begin{enumerate}[itemindent = 1em]
				\item Screen Space - Overlay 屏幕最上层，主要是2D效果。
				\item Screen Space - Camera 绑定摄像机，可以实现3D效果。
				\item World Space 世界空间，让UI变成场景中的一个物体。
			\end{enumerate}
	
		\subsection{Screen Space-Overlay -覆盖模式}
			Screen Space-Overlay（屏幕控件-覆盖模式）的\textbf{画布会填满整个屏幕空间}，并将画布下面的所有的UI元素置于屏幕的最上层，或者说\textbf{画布的画面永远“覆盖”其他普通的3D画面}，\textit{如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕}
			
			Screen Space-Overlay模式的画布有Pixel Perfect和Sort Layer两个参数：
			\begin{enumerate}[itemindent = 1em]
				\item \verb|Pixel Perfect|：只有\verb|RenderMode|为Screen类型时才有的选项。使UI元素像素对应，效果就是\textbf{边缘清晰不模糊}。
				\item \verb|Sort Layer|: \verb|Sort Layer|是UGUI专用的设置，用来指示\textbf{画布的深度}。
			\end{enumerate}
		
		\subsection{Screen Space-Camera -摄像机模式}
			与Screen Space-Overlay模式类似，画布也是\textbf{填满整个屏幕空间}，如果屏幕尺寸改变，\textbf{画布也会自动改变尺寸来匹配屏幕}。
			
			不同的是，在该模式下，\textbf{画布会被放置到摄影机前方}。在这种渲染模式下，\textbf{画布看起来 绘制在一个与摄影机固定距离的平面上}。\textit{所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面}。在此模式下，UI元素是由\verb|perspective|也就是视角设定的，视角广度由\verb|Filed of View|设置。
			
			\textbf{这种模式可以用来实现在UI上显示3D模型的需求}，比如很多MMO游戏中的查看人物装备的界面，可能屏幕的左侧有一个运动的3D人物，左侧是一些UI元素。通过设置Screen Space-Camera模式就可以实现上述的需求，效果如下图所示：
				\begin{figure}[H]
					\centering
					\includegraphics[scale=0.3]{Canva-1.png}
					\includegraphics[scale=0.3]{Canvas.png}
					\caption{摄像机模式-画布}
				\end{figure}
			
			它比Screen Space-Overlay模式的画布多了下面几个参数：
				\begin{enumerate}[itemindent = 1em]
					\item \verb|Render Camera|:渲染摄像机
					\item \verb|Plane Distance|:\textbf{画布距离摄像机的距离}
					\item \verb|Sorting Layer|: Sorting Layer是UGUI专用的设置，\textbf{用来指示画布的深度}。可以通过点击该栏的选项，在下拉菜单中点击“Add Sorting Layer”按钮进入标签和层的设置界面，或者点击导航菜单->edit->Project Settings->Tags and Layers进入该页面。
					\item \verb|Order in Layer|:\textbf{在相同的Sort Layer下的画布显示先后顺序。}数字越高，显示的优先级也就越高。
				\end{enumerate}
			
		\subsection{World Space -世界空间模式}
			World Space即世界空间模式。在此模式下，\textbf{画布被视为与场景中其他普通游戏对象性质相同的类似于一张面片（Plane）的游戏物体}。
			
			画布的尺寸可以\textbf{通过RectTransform设置}，所有的UI元素可能位于普通3D物体的前面或者后面显示。\textbf{当UI为场景的一部分时，可以使用这个模式}。
			
				\begin{figure}[H]
					\centering
					\includegraphics[scale=0.3]{Canvas-2.png}
					\includegraphics[scale=0.3]{Canvas-3.png}
					\caption{世界空间 模式- 画布}
				\end{figure}
			
		
		\subsection{使用总结}
			\begin{table}[H]
				\centering
				\caption{渲染模式使用场景说明}
				\begin{tabular}{p{4cm}<{\centering}|c|c|c|p{3cm}<{\centering}}
					\toprule
						渲染模式 & 画布匹配屏幕？& 摄像机？ & 像素对应 & 适应\\
					\midrule
						覆盖-overlay模式 & 是	& 不需要	& 可选 & 2D \\
						摄像机-camera模式 & 是	& 需要	 & 可选 & 2D+3D\\
						世界空间-world模式 & 否	& 需要	 & 不可选 & 3D\\
					\bottomrule
				\end{tabular}
			\end{table}
		
		\subsection{Canvas Scalar}
			\url{https://blog.csdn.net/qq168213001/article/details/49744899}
		
		\subsection{Layer}
		
		
	\section{RectTransform}
		\url{https://blog.csdn.net/jk823394954/article/details/53861539}
	
		\url{https://blog.csdn.net/rickshaozhiheng/article/details/51569073}
		
		\url{https://blog.csdn.net/serenahaven/article/details/78826851}
		
		核心看：\url{https://blog.csdn.net/Happy_zailing/article/details/78835482}
		
		\url{http://lib.csdn.net/article/unity3d/36875}
		
		RectTransform继承自Transform， 又增加锚点、中心轴点等信息，\textbf{主要提供一个矩形的位置、尺寸、锚点和中心信息以及操作这些属性的方法}，\textit{同时提供多种基于父级RectTransform的缩放形式}。
		
		\subsection{Pivot(中心)}
			Pivot用来指示一个\verb|RectTransform|（或者说是矩形）的中(重)心点。	
	
		\subsection{锚点- 自适应屏幕}
			\url{http://www.bubuko.com/infodetail-2384845.html}
			
			
			锚点（四个）由\verb|两个Vector2|的向量确定，这两个向量确定两个点，归一化坐标分别是\verb|Min|和\verb|Max|，\textbf{再由这两个点确定一个矩形}，\textbf{这个矩形的四个顶点就是锚点}。
			
			在\verb|Hierarchy|下新建一个Image，查看其\verb|Inspector|。
			
			\begin{figure}[H]
				\centering
				\includegraphics[scale=1.2]{Anchor.png}
				\caption{Anchor 属性}
			\end{figure}
			
			在Min的x、y值分别小于Max的x、y值时，
			\verb|Min |确定矩形\textbf{左下角}的归一化坐标，\verb|Max |确定矩形\verb|右上角|的归一化坐标。
			
			刚创建的Image，其\verb|Anchor的默认值 |为\verb|Min（0.5，0.5)|和\verb|Max（0.5，0.5）|。也就是说，\verb|Min和Max|重合了，四个锚点合并成一点。锚点在Scene中的表示如下：
			
			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.7]{anchorFirst.png}
				\caption{锚点初始位置}
			\end{figure}
		
			将Min和Max的值分别改为\verb|（0.4，0.4）|和\verb|（0.5，0.5）|。可以看见四个锚点已经分开了。
			
			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.5]{anchorChange.png}
				\caption{min Max位置、确定矩形}
			\end{figure}
			
			
			\subparagraph{需要注意} 在不同的Anchor设置下，控制该RectTransform的变量是不同的。
			
			比如设置成全部居中（默认）时，属性里包含熟悉的用来描述位置的\verb|PosX、PosY和PosZ|，以及用来描述尺寸的\verb|Width和Height|；
			
			切换成全部拉伸时，属性就变成了\verb|Left、Top、Right、Bottom|和\verb|PosZ|，\textbf{前四个属性}用来描述该RectTransform\textbf{分别离父级各边的距离}，PosZ用来描述该RectTransform在世界空间的Z坐标
			
			\paragraph{锚点类型}
				\begin{itemize}
					\item 位置类型\verb| 左上角、中心等|
					\item 拉伸类型\verb| 纵向拉伸适配、横向、整体|
				\end{itemize}
		
				\subparagraph{锚点在一块的时候}
					\begin{itemize}[itemindent = 2em]
						\item Anchor 是打在父级窗体上的
						\item Anchor 的位置在父级窗体上的标记方式是按照百分比记录的，单位（百分比）
						\item Anchor 的\verb|Min(RectTransform.anchorMin)  Max(RectTransform.anchorMax)|的信息保持一致
						\item 子物件的 坐标系 为纵向Y,横向X, 并且以\verb|Anchor| 为原点， 自身坐标用中心轴点\verb|Pivot| 表示						
						\item 子物件的 Pivot 与 Anchor  位置始终保持不变，单位（像素）
					\end{itemize}
				
				\subparagraph{锚点单向（横或者纵）分开的时候}
					\begin{itemize}[itemindent = 2em]
						\item 分开的部分(拉伸方向)与父级窗体保持一致变化，单位（百分比）
						\item 与相对方向则绝对保持，单位（像素）
					\end{itemize}
				
				\subparagraph{锚点双向分开的时候}
					\begin{itemize}[itemindent = 2em]
						\item 双向 都与 父级窗体 保持一致的变化，单位（百分比）
						\item 上-top、下-bottom、左、右边距绝对保持，单位（像素）
					\end{itemize}
		
			\paragraph{anchorMax、anchorMin}
				\verb|anchorMin.x|表示锚点在\verb|x|轴的起始点位置，\verb|anchorMax.x|表示锚点在x轴的终点位置，取值\verb|0~1|，表示\textbf{百分比值}，该值乘以父窗口的\verb|width|值就是实际锚点相对于父窗口x轴的位置。y轴与x轴同理。
		
					\begin{figure}[H]
						\centering
						\includegraphics[scale=0.8]{Anchors-3.png}
						\caption{Anchor.Min 与 Anchor.Max}
					\end{figure}
		
				这个值确定了锚点相对于父窗口的位置，是\textbf{真正决定锚点位置的值}
				
			\paragraph{offsetMax 和 offsetMin 属性}
				\subparagraph{锚点 分开时}
					在锚点分开的状态下： 锚点其实是四个钉子，分为左上，左下，右下及右上四个，每个空间在UI模型中都是一个矩形，也有左上，左下，右下及右上四个顶点，那么锚点的每个钉子可以关联一个点，即左上————左上；左下————左下；右下————右下；右上————右上。这样进行绑定。
					
					\verb|offsetMax |是RectTransform\textbf{右上角相对于右上Anchor的距离}；
			
					\verb|offsetMin |是RectTransform\textbf{左下角相对于左下Anchor的距离}。
			
					\verb|offset |可以认为是以像素为单位。
					
					\begin{figure}[H]
						\centering
						\includegraphics[scale=0.7]{Anchors-1.png}
						\caption{锚点在一起时  Offset 求取向量示例}
						\label{锚点分开时 Offset 求取向量示例}
					\end{figure}
			
				\subparagraph{锚点 在一处时}
					锚点offset 计算如下：
					
					\begin{figure}[H]
						\centering
						\includegraphics[scale=0.7]{Anchors-2.png}
						\caption{锚点分开时  Offset 求取向量示例}
					\end{figure}
			
				\subparagraph{求取}
					首先计算锚点的每个钉子到其对应的顶点矢量值，分别记作\verb|v0|，\verb|v1|，\verb|v2|，\verb|v3|， 入上图。
					
					然后比较四个向量的\verb|x|值，将\verb|x|的最大值赋给\verb|offsetMax.x|，将\verb|x|的最小值赋给\verb|offsetMin.x|；\verb|y|的值同理。
			
			\paragraph{anchoredPosition}
				\subparagraph{锚点 在一处时}
					anchorPosition 就是 \textbf{从锚点}到本物体的\textbf{轴心}（Pivot）的\textbf{向量值}.
				
				\subparagraph{锚点 分开时}
						
		\subsection{sizeDelta}
		
			\verb|sizeDelta|是\verb|offsetMax-offsetMin|的结果。在\textit{锚点全部重合的情况下}，它的值就是面板上的\verb|（Width，Height）|。
			
			\textit{在锚点完全不重合}的情况下，它是相对于父矩形的尺寸。
			
			一个常见的错误是，当RectTransform的锚点\textbf{并非全部重合时}，使用sizeDelta作为这个RectTransform的尺寸。此时拿到的结果一般来说并非预期的结果。
			
		\subsection{RectTransform.rect}	
			RectTransform.rect 的各值如图所示。
			
			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.8]{RectTransform-rect.png}
				\caption{RectTransform rect 属性}
			\end{figure}	
		
		\subsection{示例}
			\begin{lstlisting}
	GameObject webText = new GameObject("webText");
	webText.AddComponent<UnityEngine.UI.Text>();
	webText.GetComponent<UnityEngine.UI.Text>().text = "";
	webText.GetComponent<RectTransform>().anchorMin = new Vector2(0, 0);
	webText.GetComponent<RectTransform>().anchorMax = new Vector2(1, 1);
	webText.GetComponent<RectTransform>().sizeDelta = new Vector2(0, 0);
	webText.GetComponent<RectTransform>().anchoredPosition = new Vector2(0, 0);
	webText.transform.localPosition = new Vector3(0,0,0);
	webText.transform.SetParent(webObj.transform, false);
			\end{lstlisting}
			
		\subsection{FramDebug}
			查看渲染的先后顺序
			
			\verb|windows->FrameDebug |	
	\section{按钮}
		\subsection{原始Button}
			
		\subsection{Image等 -添加button 组件}
			\begin{itemize}
				\item \verb|create -> UI -> Image|
				\item \verb|Inspirit -> Add Component -> button|
			\end{itemize}	
		
		\subsection{添加事件处理脚本}
			\begin{itemize}
				\item 书写脚本并添加到Button gameObject 上
				\item 如果是Button 组件的话直接在button 组件上添加，如果是Image 则添加button 组件后再添加
				\item  添加脚本对象到\verb|onClick() |部分：\verb|+ -> gameObject 拖进来  -> 选择脚本中的具体函数|
			\end{itemize}
		
	\section{文本- Text}
		\subsection{添加文字阴影 -shadow 组件}
			\verb|addComponent -> shadow|
			
		\subsection{添加文子边框 -outline 组件}
			\verb|addComponent -> outline|
			
	\section{图片- ImageView}
		
	\section{选中标记- Toggle}
		\paragraph{Toggle 基本}
		
		\paragraph{Toggle Group}
			\subparagraph{选项栏设定}
				将panel  拖入 toggle 中的\verb|value changed|部分
				
			\subparagraph{预设}
				确定默认打开哪个panel，然后将其\verb|IsOn| 勾选，其余取消勾选	
				
	\section{滚动区域、滚动条}
	
	
	\section{其他工具条}
	
	\section{布局- Layout}
		\begin{itemize}
			\item 具体页面下创建空物体 \verb| GameObject|
			\item 其次在\verb|GameObject 下|添加组件 \verb|-> grid layout group|
			\item 最后在这个\verb|GameObject |下创建出各种Image 组件，然后这些组件将会以\verb|grid layout| 的布局进行自动调整
		\end{itemize}
	
		\subsection{grid layout group}
			\begin{itemize}
				\item  调整\verb|cell size| 进行调整子物件的大小
				\item  \verb|cell size| 的改变只影响子组件的第一层，既最下面一层
			\end{itemize}
		
		\subsection{horizontal layout group}
		
		\subsection{vertical layout group}

\chapter{物理}
	\section{流程}
		\begin{itemize}
			\item \verb|RigidBody |:创建，以完成受力接收。
			\item \verb|Physical Material|：创建，以完成多种力的添加。
			\item \verb|Material |：拖入材质球。
		\end{itemize}
	
	\section{刚体}
	
	
	\section{碰撞器}
	
	
	\section{物理材质}
	
	
	\section{触发器}
	
	
	\section{射线}
	
	
	\section{关节}
		
\chapter{动画}
	\section{流程}
		\dirtree{%
			.1 .
			.2 在要动态显示的物体的父节点上创建\textbf{Animation} .
			.3 编辑Animation .
			.4 在脚本中获取该父亲节点上的Animator 组件 .
			.5 播放动画 .
		}
		
		
	
	\section{iTween 动画用法}
		

\chapter{粒子系统}

		
\chapter{着色器渲染}



\chapter{资源管理- AssetBundle}
	\section{工作流程}
		\dirtree{%
			.1 \textbf{AssetBundle 的使用流程} . 
			.2 1- 创建AssetBundle .
			.3 2- 上传到Server .
			.4 3- 游戏运行时根据需要下载AssetBundle 文件 .
			.5 4- 解析加载Assets .
			.6 5- 使用完后释放内存等资源 .
		}
	\section{创建}
		通过编译管线BuildPipeline来创建AssetBundle文件，总共有三种方法,具体如下所示。
		\subsection{BuildAssetBundle}
			该API将编辑器中的任意类型的Assets打包成一个AssetBundle，适用于\textbf{对单个大规模场景的细分}。
			
			\begin{itemize}
				\item 名称：\textbf{BuildPipeline.BuildAssetBundle}
				\item 参数-1：\textbf{mainAsset} : Object
				\item 参数-2：\textbf{assets} : Object[]
				\item 参数-3：\textbf{pathName} : string
				\item 参数-4：\textbf{options} : BuildAssetBundleOptions
				\item 参数-5：\textbf{targetPlatform} : BuildTarget = BuildTarget.WebPlayer
				\item 返回值：\textbf{bool}
			\end{itemize}
			
			\paragraph{BuildAssetBundleOptions}
				\subparagraph{CompleteAssets}
				
				\subparagraph{CollectDependencies}
				
				\subparagraph{DisableWriteTypeTree}
				
				\subparagraph{DeterministricAssetBundle}
				
				\subparagraph{UncompressedAssetBundle}

			\paragraph{AssetBundle之间的依赖}	
				如果游戏中的某个资源被多个资源引用（例如游戏中的Material），单独创建AssetBundle会使多个AssetBundle都包含被引用的资源（这里跟flash编译选项中的链接选项有些像），从而导致资源变大，这里可以通过指定AssetBundle之间的依赖关系来减少最终AssetBundle文件的大小（把AssetBundle解耦）。
				
				具体方法是在创建AssetBundle之前调用BuildPipeline.PushAssetDependencies和BuildPipeline.PopAssetDependencies来创建AssetBundle之间的依赖关系，它的用法就是一个栈，后压入栈中的元素依赖栈内的元素。
			
		\subsection{BuildStreamedSceneAssetBundle}
			该API将一个或多个场景中的资源及其所有依赖以流加载的方式打包成AssetBundle，一般适用于\textbf{多单个或多个场景进行集中打包}
			
			\begin{itemize}
				\item 名称：\textbf{BuildPipeline.BuildStreamedSceneAssetBundle}
				\item 参数-1：\textbf{level} : string[]
				\item 参数-2：\textbf{locationPath} : string
				\item 参数-3：\textbf{target} : BuildTarget
				\item 返回值：\textbf{String}
			\end{itemize}

			
			
		\subsection{BuildAssetBundleExplicitAssetNames}
			该API功能与a相同，但创建的时候可以为每个Object指定一个自定义的名字。（一般不太常用）
			
			\begin{itemize}
				\item 名称：\textbf{BuildPipeline.BuildAssetBundleExplicitAssetNames}
				\item 参数-1：\textbf{assets} : Object[]
				\item 参数-2：\textbf{assetNames} : string[]
				\item 参数-3：\textbf{pathName} : string
				\item 参数-4：\textbf{options} : BuildAssetBundleOptions
				\item 参数-5：\textbf{targetPlatform} : BuildTarget
				\item 返回值：\textbf{bool}
			\end{itemize}			
		    
	\section{使用}
	
	\section{卸载}
	
	\section{内存模型}
	
	\section{其他}

\chapter{Editor 扩展}
	Unity编辑器扩展是扩展Unity菜单功能，也可以说是自定义Unity菜单，以此来便利我们能够更快捷地开发游戏。
	\section{流程}
		\begin{enumerate}
			\item 在Asset文件夹下\textbf{创建一个文件夹}\verb|Editor|，如果已经存在则忽略此步
			\item 在\verb|该Editor| 文件夹下，\textbf{创建一个}\verb|C#|\textbf{脚本}，无需继承于任何类
			\item \textbf{引用}\verb|UnityEditor| \textbf{命名空间}
			\item \textbf{写静态方法}\textit{既菜单的功能}，类似于\verb|[SerilizedFiled]|下的东西,与\verb|[Menuitem("Netease/xx")]|一一对应。
			\item \textbf{给该方法上添加}\verb|[Menuitem("")]|特性
		\end{enumerate}	
	
	\section{在编辑器上增加一个MenuItem}
	
	
	\section{创建一个对话框}
	
	
	\section{扩展Inspector面板}
	
	
	
	\section{编辑器插件常用函数}
		\subsection{资源导入回调函数}
			当导入资源到Unity 项目中的某个资源文件夹下时，当Unity Editor获得焦点后，会在加载完资源后，先为其创建.meta 文件，然后再触发该回调函数。
			
			\begin{lstlisting}[frame=line]
	public class TestBundleNameAndTexture : UnityEditor.AssetPostprocessor
	{
	    static void OnPostprocessAllAssets(  // 这个函数必须为静态的，其他可以不是！
	        string[] importedAssets,
	        string[] deletedAssets,
	        string[] movedAssets,
	        string[] movedFromAssetPaths)
	    {
	        foreach (var path in importedAssets)
	        {
	            DirectoryInfo dir = new DirectoryInfo(path);
	            Debug.Log(dir.Parent.FullName);
	            BundelNameCreater.Proc(dir.Parent.FullName);
	        }
	    }
	
	}
			\end{lstlisting}
	\section{一些常用的Inspector属性设置}
	
	
	\section{参考}
		\url{https://blog.csdn.net/puppet_master/article/details/51012298}
		
		\url{http://blog.csdn.net/asd237241291/article/details/38235091}
		
		\url{http://blog.sina.com.cn/s/blog_471132920101n8cr.html}
		
\chapter{跨平台发布apk}
	\section{流程}
		\begin{itemize}
			\item 安装 JavaSDK、Android Studio 并在SDK manager 里添加对应的API包
			\item 在unity 中的\verb|edit |选项下的\verb|preferences|, 并选中\verb|External Tools| 选项，配置\verb|JDK |和\verb|Android SDK| 安装位置。
			\item 在unity 中的\verb|File -> Build Settings|中，添加需要添加的场景，并选择对应的平台（Android， IOS）等
			\item 在unity 中的\verb|Build Settings |中的\verb|Player Settings |设置以下几个重要内容。
				\begin{enumerate}
					\item \verb|Company Name |
					\item \verb|Product Name |
					\item \verb|Default Icon |:192$\times$192
					\item \verb|Default Orientation |
					\item \verb|Other Settings -> Identification |:修改为\verb|com.netease(Or Other).TestName(Or Other)|
				\end{enumerate}
		\end{itemize}	
	
	\section{Apk 安装常见错误}
		\url{http://mumu.163.com/2017/03/30/25905_680657.html}


\chapter{调试技巧}
	\section{以父类为基点}
		在Inspector 中查看是否存在父类脚本\verb|[SerializedField]| 的变量，这样方便对空间进行查找，并且添加新的\textbf{控制}			
	
	
		    
\end{document} 
 		    